<!DOCTYPE html>

<html>

<head>
	
<!--

GLBert.html

A WebGL Implementation of QBert

Jorge Catarino, Ã“scar Pimentel - Novembro 2020

-->
	
<title>GL*Bert</title>

<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<!--

The simple vertex and fragment shaders.

Using a vertex coordinate buffer and a vertex colour buffer.

Passing the Model-View Matrix and the Projection Matrix. 

-->

<img id='blockLevel1' hidden="true" src = './images/changeto.jpg'>

<script id="shader-vs" type="x-shader/x-vertex">
	
	// Original Model data 
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexColor;
	
	// Scene transformations
    uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	
	varying vec4 fColor;

	// For the Phong Illumination Model - NEW
    
    attribute vec3 vNormal;
    uniform vec4 lightPosition;
    uniform vec4 viewerPosition;
    
    // The light intensity multiplied by the material reflection coefficients

	uniform vec3 ambientProduct;
	uniform vec3 diffuseProduct;
	uniform vec3 specularProduct;
    uniform float shininess;

    varying vec4 vertexColor;
    
    void main(void) {
		
		// To allow seeing the points drawn
		
		gl_PointSize = 5.0;
		
		// Just converting the (x,y,z) vertices to Homogeneous Coord.
		
		// And multiplying by the Projection and the Model-View matrix
		
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        
        // Converting the RGB color value to RGBA
        
		vertexColor = vec4(aVertexColor, 1.0);

		// Phong Illumination Model
        
        // pos is vertex position after applying the global transformation
    
        vec3 pos = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;
    
        // vector from vertex position to light source
    
        vec3 L;
        
        // check for directional light
    
        if(lightPosition.w == 0.0) 
        
			L = normalize( lightPosition.xyz );
        
        else 
        
			L = normalize( lightPosition.xyz - pos );
			
		// Vector from the vertex position to the eye
		
		vec3 E;
		
		// The viewer is at the origin or at an indefinite distance
		// on the ZZ axis
		
		if(viewerPosition.w == 1.0) 
        
			// At the origin
			
			E = -normalize( pos );
        
        else 
        
			// On the ZZ axis
			
			E = vec3(0,0,1);
		    
        // Halfway vector
    
        vec3 H = normalize( L + E );

        // Transform vertex normal into eye coordinates
    
        vec4 N = normalize( uMVMatrix * vec4(vNormal, 0.0));

        // Compute terms in the illumination equation
        
        // Ambient component is constant
        
		vec4 ambient = vec4( ambientProduct, 1.0 );
		
		// Diffuse component 
		
		float dotProductLN = L[0] * N[0] + L[1] * N[1] + L[2] * N[2]; 
		
        float cosNL = max( dotProductLN, 0.0 );
    
        vec4  diffuse = vec4( diffuseProduct * cosNL, 1.0 );
        
        // Specular component

        float dotProductNH = N[0] * H[0] + N[1] * H[1] + N[2] * H[2]; 
		
		float cosNH = pow( max( dotProductNH, 0.0 ), shininess );

		vec3 specular = specularProduct * cosNH;
		
		vec3 object_color = vec3(vertexColor[0], vertexColor[1], vertexColor[2]) * (1.0 - cosNH);

		vec3 color = specular + object_color;
		vec4 adder = vec4(color[0], color[1], color[2], 1.0);
    
        if( dotProductLN < 0.0 ) {
	
			adder = vec4(0.0, 0.0, 0.0, 1.0);
        } 

		// Adding the 3 components
		
        fColor = ambient + diffuse + adder;
    }
</script>

<script id="shader-fs" type="x-shader/x-fragment">

	precision mediump float;
	
	varying vec4 vertexColor;
	varying vec4 fColor;
	
	void main(void) {
		
		// Using the passed vertex color
		
		gl_FragColor = fColor;
	}

</script>

<style>
	@font-face {
		font-family: 'arcade';
		src: url('./fonts/ARCADE_N.TTF');
	}

	.container {
	position: relative;
	}
	#text {
		position: absolute;
		left: 0px;
		top: 0px;
		z-index: 10;
	}
</style>

<!-- The JS files -->
<script type="text/javascript" src="sounds.js"></script>
<script type="text/javascript" src="utils/webgl-utils.js"></script>
<script type="text/javascript" src="utils/maths.js"></script>
<script type="text/javascript" src="utils/initShaders.js"></script>
<script type="text/javascript" src="utils/events.js"></script>
<script type="text/javascript" src="utils/countFrames.js"></script>
<script type="text/javascript" src="utils/models.js"></script>

<!-- WebGL code -->
<script type="text/javascript" src="buffers.js"></script>
<script type="text/javascript" src="gameEntities.js"></script>
<script type="text/javascript" src="animation.js"></script>
<script type="text/javascript" src="GLBert.js"></script>

</head>

<body onload="runWebGL();">

	<div class="container">
		<canvas id="my-canvas" width="800" height="600"></canvas>
		<canvas id="text" width="800" height="600"></canvas>		
	</div>
</body>

</html>
